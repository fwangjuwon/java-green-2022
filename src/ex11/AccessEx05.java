package ex11;

//1. 하나의 자바 파일은 두개의 public class가 있을 수 없다 (import때문에)
class 엘리스 {
    private int 목마름; // 2. 선언만해야되. 여기에 값을 넣는 순간 모든 객체의 값이 동일해진다. 0~100 //7. 상태 앞에 private붙이자..(상태는
                     // 행위를 통해 변경해야되니까!)

    // 3. 생성자 시작: 내부적으로 메소드다 (stack) - 생성자도 메소드라서 오버로딩 가능하다.
    엘리스(int 목마름) {
        this.목마름 = 목마름;
    } // 생성자 끝

    // 5. 메소드 만들기 시작
    public void 물마시기() { // 8.메소드 앞에는 public 을 붙이자. 이 통로를 통해서 목마름(상태)에 접근하는것이야
        목마름 = 목마름 - 20;
    }

    // 9. 확인하는 메소드 만들자. 상태마다 무조건 변경메소드와 확인 메소드가 필요하다 (private니까!) >클래스에 커서두고 alt +
    // enter 치면, generate geters and setters 툴 제공!
    public int 갈증확인하기() {
        return 목마름;
    }
}

public class AccessEx05 {
    public static void main(String[] args) {
        엘리스 e1 = new 엘리스(100); // 4. 오류 생기면 값을 넣어줘야되
        // e1.목마름 = 50; // 문법적으로는 가능하지만, oop적으로는 안된다. 이유: 상태를 직접 바꿨기 때문에 (상태는 행위를 통해서
        // 변경해야되) > 메소드 만들자.
        // 6. sysout시키자.
        System.out.println("엘리스의 갈증 지수는 " + e1.갈증확인하기()); // 9. 목마름 > 갈증확인하기로 바꾸자. (갈증확인하기에 return이 있어야하는 이유!!) 문자열이랑
                                                          // 결합되면 무조건 String타입으로 바뀐다.
        // 자바는 기본자료형과 문자를 더하면 결합이 되고 문자열 타입으로 변환된다.
        e1.물마시기();
        System.out.println("엘리스의 갈증 지수는 " + e1.갈증확인하기());

        // 신입에게 목마름을 40으로 만들어라고 시킴
        // e1.목마름 = 40;
        e1.물마시기(); // 10. 신입이 이제 정신을 차리고 두번 메소드를 때린다. > private는 건들지마! > 상태는 행위를 통해 변경되구나!
        e1.물마시기();
        System.out.println("앨리스의 갈증 지수는 " + e1.갈증확인하기());
        // 틀림: 상태는 행위를 통해서 변경해야해 > 설계를 제대로 안한 팀장 잘못!! > 7. 변수에 접근 못하게 private붙이자. 8. 행위
        // 앞에 public붙이자. > 변수에 접근 안되어서 오류난다. >변수 확인하기 위한 메소드를 만들어야해
    }
}
